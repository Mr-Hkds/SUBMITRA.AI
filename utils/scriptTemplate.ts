import { FormAnalysis, ScriptConfig } from '../types';
import { TokenMetadata } from '../services/securityService';

export const generateAutomationScript = (
    analysis: FormAnalysis,
    config: ScriptConfig,
    formUrl: string,
    tokenMetadata?: TokenMetadata
) => {
    const { questions } = analysis;
    const { targetCount, delayMin, delayMax, names = [], customFieldResponses = {} } = config;

    // clean url to ensure it points to the form, not the response page
    const cleanUrl = formUrl.split('?')[0].replace(/\/formResponse$/, '/viewform');

    const serializedConfig = JSON.stringify({
        targetCount,
        delayMin,
        delayMax,
        formUrl: cleanUrl,
        appOrigin: typeof window !== 'undefined' ? window.location.origin : 'https://submitra.vercel.app', // Capture app URL
        names,
        customFieldResponses,
        token: tokenMetadata || null,
        questions: questions.map(q => ({
            id: q.id,
            title: q.title,
            type: q.type,
            required: q.required,
            options: q.options,
            suggestions: q.aiTextSuggestions || []
        }))
    });

    return `
/* 
 * SUBMITRA - GOLD EDITION CONTROLLER
 * Generated by Submitra
 * 
 * FEATURES:
 * - Persistent Controller (Survives page reloads)
 * - Intelligent Input Matching (Name, Email, Phone, Age)
 * - Robust Dropdown & Radio Logic
 * - Zero-Detection Delays
 * - Cryptographic Token Validation
 * - Anti-Tampering Protection
 */

(async function() {
  const CONFIG = ${serializedConfig};
  
  // --- SECURITY: Token Validation ---
  const validateToken = async () => {
    if (!CONFIG.token) {
      console.error('ðŸ”’ SECURITY ERROR: No token found. This script is invalid.');
      alert('Security Error: This script is missing authentication token. Please regenerate from Submitra.');
      return false;
    }
    
    // Check for replay (Browser-level protection)
    const storageKey = 'af_token_' + CONFIG.token.tokenId;
    if (localStorage.getItem(storageKey)) {
        console.error('ðŸ”’ SECURITY ERROR: Token already used on this device.');
        alert('Security Error: This automation script has already been executed on this device. Please generate a new one.');
        return false;
    }
    
    const { tokenId, userId, formUrl, maxResponses, expiresAt, signature } = CONFIG.token;
    
    // Check expiration
    const now = Date.now();
    if (now > expiresAt) {
      const expiredDate = new Date(expiresAt).toLocaleString();
      console.error(\`ðŸ”’ SECURITY ERROR: Token expired on \${expiredDate}\`);
      alert(\`Security Error: This script expired on \${expiredDate}. Please generate a new one.\`);
      return false;
    }
    
    // Validate signature (client-side verification)
    const tokenData = \`\${tokenId}|\${userId}|\${formUrl}|\${maxResponses}|\${expiresAt}\`;
    
    // Extract timestamp from tokenId for secret key
    const parts = tokenId.split('-');
    if (parts.length < 2) {
      console.error('ðŸ”’ SECURITY ERROR: Invalid token format');
      alert('Security Error: Token format is invalid. Please regenerate.');
      return false;
    }
    
    const timestamp = parseInt(parts[1]);
    if (isNaN(timestamp)) {
      console.error('ðŸ”’ SECURITY ERROR: Invalid token timestamp');
      alert('Security Error: Token timestamp is invalid. Please regenerate.');
      return false;
    }
    
    // Generate expected signature
    const secret = \`\${userId}-\${timestamp}-submitra-secure-2025\`;
    const encoder = new TextEncoder();
    const keyData = encoder.encode(secret);
    const messageData = encoder.encode(tokenData);
    
    try {
      const key = await crypto.subtle.importKey(
        'raw',
        keyData,
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['sign']
      );
      
      const signatureBuffer = await crypto.subtle.sign('HMAC', key, messageData);
      const expectedSignature = Array.from(new Uint8Array(signatureBuffer))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
      
      if (signature !== expectedSignature) {
        console.error('ðŸ”’ SECURITY ERROR: Token signature mismatch. Script has been tampered with.');
        alert('Security Error: This script has been modified and is no longer valid. Please regenerate from Submitra.');
        return false;
      }
    } catch (e) {
      console.error('ðŸ”’ SECURITY ERROR: Signature validation failed', e);
      alert('Security Error: Unable to validate script authenticity. Please regenerate.');
      return false;
    }
    
    // Check if targetCount exceeds token limit
    if (CONFIG.targetCount > maxResponses) {
      console.error(\`ðŸ”’ SECURITY ERROR: Requested \${CONFIG.targetCount} responses but token only allows \${maxResponses}\`);
      alert(\`Security Error: This script is authorized for \${maxResponses} responses, but \${CONFIG.targetCount} were requested. Please regenerate.\`);
      return false;
    }
    
    // Check form URL match
    if (CONFIG.formUrl !== formUrl) {
      console.error('ðŸ”’ SECURITY ERROR: Form URL mismatch');
      alert('Security Error: This script is for a different form. Please regenerate.');
      return false;
    }
    
    console.log('âœ… Token validated successfully');
    console.log(\`ðŸ“Š Authorized for \${maxResponses} responses\`);
    console.log(\`â° Expires: \${new Date(expiresAt).toLocaleString()}\`);
    
    return true;
  };
  
  // Validate token before proceeding
  const isValid = await validateToken();
  if (!isValid) {
    return; // Stop execution if token is invalid
  }
  
  // --- UI HELPER: Controller HUD ---
  const createHUD = () => {
    const existing = document.getElementById('submitra-hud');
    if (existing) existing.remove();

    const hud = document.createElement('div');
    hud.id = 'submitra-hud';
    hud.style.cssText = 'position:fixed;bottom:20px;right:20px;width:320px;background:#0f172a;color:white;padding:16px;border-radius:12px;z-index:999999;box-shadow:0 10px 25px rgba(0,0,0,0.5);font-family:monospace;border:1px solid #334155;display:flex;flex-direction:column;gap:8px;opacity:0.95;';

    const header = document.createElement('div');
    header.style.cssText = 'display:flex;justify-content:space-between;align-items:center;';
    
    const title = document.createElement('span');
    title.style.cssText = 'font-weight:bold;color:#fbbf24;font-size:14px;'; // Gold color
    title.textContent = 'Submitra Gold';
    
    const statusBadge = document.createElement('span');
    statusBadge.id = 'af-status';
    statusBadge.style.cssText = 'font-size:10px;background:#1e293b;padding:2px 6px;border-radius:4px;color:#94a3b8;font-weight:bold;';
    statusBadge.textContent = 'IDLE';

    header.appendChild(title);
    header.appendChild(statusBadge);
    hud.appendChild(header);

    const progressRow = document.createElement('div');
    progressRow.style.cssText = 'font-size:12px;color:#94a3b8;display:flex;justify-content:space-between;';
    
    const countSpan = document.createElement('span');
    countSpan.id = 'af-count';
    countSpan.textContent = '0 / ' + CONFIG.targetCount;
    
    progressRow.appendChild(document.createTextNode('Progress:'));
    progressRow.appendChild(countSpan);
    hud.appendChild(progressRow);

    const barContainer = document.createElement('div');
    barContainer.style.cssText = 'width:100%;height:4px;background:#1e293b;border-radius:2px;overflow:hidden;margin-top:2px;';
    const bar = document.createElement('div');
    bar.id = 'af-bar';
    bar.style.cssText = 'width:0%;height:100%;background:#fbbf24;transition:width 0.3s;';
    barContainer.appendChild(bar);
    hud.appendChild(barContainer);

    const log = document.createElement('div');
    log.id = 'af-log';
    log.style.cssText = 'font-size:11px;color:#64748b;height:40px;overflow:hidden;margin-top:4px;line-height:1.4;';
    log.textContent = 'Controller ready.';
    hud.appendChild(log);

    // Disclaimer
    const disclaimer = document.createElement('div');
    disclaimer.style.cssText = 'font-size:10px;color:#f59e0b;margin-top:8px;padding:6px;background:rgba(245, 158, 11, 0.1);border-radius:6px;border:1px solid rgba(245, 158, 11, 0.2);text-align:center;line-height:1.3;';
    disclaimer.textContent = 'âš ï¸ Important: Keep this tab active and screen open for the automation to work correctly.';
    hud.appendChild(disclaimer);

    document.body.appendChild(hud);
    return hud;
  };

  const updateHUD = (count, msg, status) => {
    const countEl = document.getElementById('af-count');
    const barEl = document.getElementById('af-bar');
    const logEl = document.getElementById('af-log');
    const statusEl = document.getElementById('af-status');
    
    // Mission Control Relay
    if (typeof reportToMissionControl === 'function') {
        reportToMissionControl({ count, msg, status, timestamp: Date.now() });
    }
    
    if (countEl) countEl.innerText = \`\${count} / \${CONFIG.targetCount}\`;
    if (barEl) barEl.style.width = \`\${(count / CONFIG.targetCount) * 100}%\`;
    if (logEl && msg) logEl.innerText = msg;
    if (statusEl && status) {
       statusEl.textContent = status;
       statusEl.style.color = status === 'RUNNING' ? '#38bdf8' : (status === 'DONE' ? '#4ade80' : '#f87171');
    }
  };

  // --- UTILS ---
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));
  const randomDelay = () => sleep(Math.random() * (CONFIG.delayMax - CONFIG.delayMin) + CONFIG.delayMin);
  // Normalize: Keep alphanumeric and spaces, remove symbols
  const normalize = (str) => (str || '').toLowerCase().replace(/[^a-z0-9 ]/g, '').replace(/\s+/g, ' ').trim();
  const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  
  const CONTEXTUAL_POISON = /\b(of your|of the|favorite|favourite|prefer|which|opinion|affect|impact|influence|important|matter|agree|disagree|think|believe|rate|how often|how many|how much|do you|did you|would you|have you|can you|should|about|regarding|related|mention|describe|explain|suggest|recommend|why|reason|experience|feedback|comment|review|thought|feeling|satisfaction|interest|awareness|familiar|knowledge)\b/i;

  const isPersonalName = (title) => {
    const t = (title || "").trim();
    if (t.length > 80) return false;
    const lower = t.toLowerCase();
    if (CONTEXTUAL_POISON.test(lower)) return false;
    if (/company|brand|product|school|university|business|organization|startup|manager|boss|friend|spouse|father|mother|parent|partner|child|pet|movie|song|game|app|book|place|city|country|team|food|website|channel|series|college|institute|hospital|store|shop/i.test(lower)) return false;
    return /^name\s*[\*\?]?\s*$/i.test(t) ||
           /^(your|enter|type|write|provide|give|mention|respondent|student|participant|candidate|applicant|member|employee|full|first|last|nick)\s*(name|names)/i.test(lower) ||
           /^name\s+(of the respondent|of student|of participant|of candidate|of applicant|of member|of employee)/i.test(lower) ||
           /^(full|first|last)\s*name/i.test(lower) ||
           /\b(your\s+name|your\s+full\s+name|your\s+first\s+name|your\s+last\s+name)\b/i.test(lower);
  };

  const isPersonalEmail = (title) => {
    const t = (title || "").trim();
    if (t.length > 80) return false;
    const lower = t.toLowerCase();
    if (CONTEXTUAL_POISON.test(lower)) return false;
    if (/company|brand|manager|boss|friend|spouse|father|mother|parent|partner|child|vs|or phone|communication|notification|subscribe|marketing/i.test(lower)) return false;
    return /^e?-?mail\s*(address|id)?\s*[\*\?]?\s*$/i.test(t) ||
           /^(your|enter|type|write|provide|give)\s*(e?-?mail|email)/i.test(lower) ||
           /\b(your\s+e?-?mail|your\s+mail\s*(id|address)?)\b/i.test(lower) ||
           /^e?-?mail\s*(address|id)\b/i.test(lower);
  };

  const isPhoneQuestion = (title) => {
    const t = (title || "").trim();
    if (t.length > 80) return false;
    const lower = t.toLowerCase();
    if (CONTEXTUAL_POISON.test(lower)) return false;
    if (/manager|boss|friend|spouse|father|mother|parent|partner|child|company|brand/i.test(lower)) return false;
    return /^(phone|mobile|contact|whatsapp|telephone)\s*(number|no\.?)?\s*[\*\?]?\s*$/i.test(t) ||
           /^(your|enter|type|write|provide|give)\s*(phone|mobile|contact|whatsapp|cell)/i.test(lower) ||
           /\b(your\s+(phone|mobile|contact|whatsapp|cell)\s*(number|no\.?)?)\b/i.test(lower) ||
           /^(phone|mobile|contact)\s*(number|no\.?)\b/i.test(lower);
  };

  const isGenderQuestion = (title, options) => {
    const t = (title || "").trim();
    if (t.length > 100) return false;
    const lower = t.toLowerCase();
    if (/\b(affect|impact|influence|important|matter|opinion|think|believe|prefer|agree|disagree)\b/i.test(lower)) return false;
    if (!/gender|sex\b/i.test(lower)) return false;
    return options.some((opt) => {
        const val = typeof opt === 'string' ? opt : opt.value;
        return /\b(male|female|other|non.?binary|trans|prefer not)\b/i.test(val || "");
    });
  };
  
  const selectWeighted = (options) => {
    if (!options || options.length === 0) return { value: "" };
    const validOptions = options.filter(o => (o.weight || 0) > 0);
    if (validOptions.length === 0) return options[Math.floor(Math.random() * options.length)];
    
    const total = validOptions.reduce((acc, opt) => acc + (opt.weight || 0), 0);
    let random = Math.random() * total;
    
    for (const opt of validOptions) {
      if (random < (opt.weight || 0)) return opt;
      random -= (opt.weight || 0);
    }
    return validOptions[validOptions.length - 1];
  };

  // --- DOM OPS ---

  /* ENHANCED CLICK SIMULATION */
  const simulateClick = (win, el) => {
    if (!el) return;
    el.scrollIntoView({block: 'center', behavior: 'instant'});
    
    const opts = { view: win, bubbles: true, cancelable: true, buttons: 1 };
    
    // Modern apps often listen to pointer events
    try {
        el.dispatchEvent(new PointerEvent('pointerdown', opts));
        el.dispatchEvent(new MouseEvent('mousedown', opts));
        el.dispatchEvent(new PointerEvent('pointerup', opts));
        el.dispatchEvent(new MouseEvent('mouseup', opts));
        el.dispatchEvent(new MouseEvent('click', opts));
    } catch (e) {
        // Fallback for older browsers
        el.dispatchEvent(new MouseEvent('mousedown', opts));
        el.dispatchEvent(new MouseEvent('mouseup', opts));
        el.dispatchEvent(new MouseEvent('click', opts));
    }
  };

  /* AGGRESSIVE TYPING SIMULATION */
  const simulateTyping = async (win, element, value) => {
    // ... (existing typing logic is fine, keeping for context if needed, but not replacing here to save tokens unless requested)
    // Actually, I should just leave simulateTyping as is and only replace simulateClick if I can target it properly.
    // However, the tool requires a contiguous block.
    // I will just replace simulateClick and let simulateTyping be or use multi-replace if they are far apart.
    // They are lines 243 and 253. Close enough.
    if (!element) return;
    
    // 1. Focus & Click
    element.focus();
    element.dispatchEvent(new Event('focus', { bubbles: true }));
    simulateClick(win, element);
    await sleep(20);

    // 2. Try Trusted execCommand (Behaves like real user typing)
    let success = false;
    try {
        success = win.document.execCommand('insertText', false, value);
    } catch (e) {}

    // 3. Fallback: React Setter Hack + Full Event Chain
    if (!success || element.value !== value) {
        // Safe Property Descriptor Access
        const getSetter = (obj, prop) => {
            let limit = 5; // Safety break
            let curr = obj;
            while (curr && limit > 0) {
                const desc = Object.getOwnPropertyDescriptor(curr, prop);
                if (desc && desc.set) return desc.set;
                curr = Object.getPrototypeOf(curr);
                limit--;
            }
            return null;
        };

        const setter = getSetter(element, 'value');
        
        if (setter) {
            setter.call(element, value);
        } else {
            element.value = value;
        }
        
        // React 16/17 tracker hack
        const tracker = element._valueTracker;
        if (tracker) tracker.setValue(value);
        
        element.dispatchEvent(new InputEvent('input', { bubbles: true }));
    }

    // 4. Fire Keyboard & Change Events (To satisfy any listeners)
    element.dispatchEvent(new KeyboardEvent('keydown', { bubbles: true }));
    element.dispatchEvent(new KeyboardEvent('keypress', { bubbles: true }));
    element.dispatchEvent(new KeyboardEvent('keyup', { bubbles: true }));
    element.dispatchEvent(new Event('change', { bubbles: true }));
    
    // 5. Blur to commit
    element.dispatchEvent(new Event('blur', { bubbles: true }));
    element.blur();
  };

  const fillForm = async (win, runIndex) => {
    // ... (fillForm logic)
    // I will use a separate replace for the loop logic to avoid huge chunks
   const doc = win.document;
   
    // --- SPECIAL HANDLING: Global Email Checkbox ---
    // Finds "Record <email>" checkbox even if it's not in a listitem
    try {
        // Strategy A: Find checkbox by aria-label or local text
        const allCheckboxes = Array.from(doc.querySelectorAll('div[role="checkbox"]'));
        for (const cb of allCheckboxes) {
            // 1. Direct Text/Label check
            const ownText = normalize(cb.innerText || cb.getAttribute('aria-label') || "");
            if ((ownText.includes('record') && ownText.includes('email')) || ownText.includes('included with my response')) {
                if (cb.getAttribute('aria-checked') !== 'true') simulateClick(win, cb);
                continue;
            }

            // 2. Parent Context Check (Up to 4 levels)
            let parent = cb.parentElement;
            let found = false;
            for(let i=0; i<4; i++) {
                if(!parent) break;
                const pText = normalize(parent.innerText);
                if ((pText.includes('record') && pText.includes('email')) || pText.includes('included with my response')) {
                    if (cb.getAttribute('aria-checked') !== 'true') {
                        simulateClick(win, cb);
                        found = true;
                    }
                    break;
                }
                parent = parent.parentElement;
            }
            if(found) continue;
        }

        // Strategy B: Find the TEXT first, then find the checkbox next to it
        // Useful if the text is in a <label> or sibling div
        if (allCheckboxes.every(cb => cb.getAttribute('aria-checked') !== 'true')) { 
             const allDivs = Array.from(doc.querySelectorAll('div, label, span'));
             const textEl = allDivs.find(el => {
                 const t = normalize(el.innerText);
                 return t.includes('record') && t.includes('email') && t.includes('response') && el.childElementCount === 0; // Leaf node
             });
             
             if (textEl) {
                 // Climb up to find a container with a checkbox
                 let container = textEl.parentElement;
                 while(container && container !== doc.body) {
                     const cb = container.querySelector('div[role="checkbox"]');
                     if (cb) {
                         if (cb.getAttribute('aria-checked') !== 'true') simulateClick(win, cb);
                         break;
                     }
                     container = container.parentElement;
                     if (container.scrollHeight > 500) break; // Don't go too high
                 }
             }
        }

    } catch(e) {}

    const items = Array.from(doc.querySelectorAll('div[role="listitem"]'));
    
    for (const item of items) {
      // SECTION FIX: Check if field is visible
      const style = win.getComputedStyle(item);
      if (style.display === 'none' || style.visibility === 'hidden' || item.offsetParent === null) continue;
      // Get Heading
      const heading = item.querySelector('div[role="heading"]');
      const itemTitleRaw = heading ? heading.innerText : item.innerText;
      const itemTitle = normalize(itemTitleRaw);
      
      // 1. Matched Logic
      const question = CONFIG.questions.find(q => {
         const t = normalize(q.title);
         return itemTitle.includes(t) || t.includes(itemTitle);
      });

      // 2. Check if already filled
      const isRadioFilled = item.querySelector('div[role="radio"][aria-checked="true"]');
      const isCheckboxFilled = item.querySelector('div[role="checkbox"][aria-checked="true"]');
      // For text, check if value is substantial (more than 1 char)
      const textInput = item.querySelector('input:not([type="hidden"]), textarea');
      const isTextFilled = textInput && textInput.value && textInput.value.length > 0;
      
      if (isRadioFilled || isCheckboxFilled || isTextFilled) continue;

      // 3. Skip if optional and no question logic found
      const isRequired = itemTitleRaw.includes('*') || item.dataset.required === "true";
      
      // SPECIAL HANDLE: Google Forms "Record <email>" checkbox
      // This often appears at the top and needs to be checked
      if (itemTitleRaw.includes('Record') && itemTitleRaw.includes('as the email')) {
          const emailCheckbox = item.querySelector('div[role="checkbox"]');
          if (emailCheckbox && emailCheckbox.getAttribute('aria-checked') !== 'true') {
              simulateClick(win, emailCheckbox);
              await sleep(500);
              continue;
          }
      }

      if (!question && !isRequired) {
         if (Math.random() > 0.8) continue; 
      }

      await randomDelay();

      try {
        // A. Radio Groups
        const radios = Array.from(item.querySelectorAll('div[role="radio"]'));
        if (radios.length > 0) {
            let target = null;
            if (question) {
                const choice = normalize(selectWeighted(question.options).value);
                target = radios.find(r => {
                   const val = normalize(r.dataset.value || r.getAttribute('aria-label') || r.innerText);
                   return val === choice;
                });
            }
            if (!target) target = radios[Math.floor(Math.random() * radios.length)];
            simulateClick(win, target);
            continue;
        }

        // B. Checkboxes
        const checkboxes = Array.from(item.querySelectorAll('div[role="checkbox"]'));
        if (checkboxes.length > 0) {
             let target = null;
             if (question) {
                 const choice = normalize(selectWeighted(question.options).value);
                 target = checkboxes.find(c => {
                    const val = normalize(c.dataset.value || c.getAttribute('aria-label') || c.innerText);
                    return val === choice;
                 });
             }
             if (!target) target = checkboxes[Math.floor(Math.random() * checkboxes.length)];
             if (target.getAttribute('aria-checked') !== 'true') simulateClick(win, target);
             continue;
        }

        // C. Dropdowns
        const dropdown = item.querySelector('div[role="listbox"]');
        if (dropdown) {
             simulateClick(win, dropdown);
             await sleep(600); 
             
             const allOptions = Array.from(doc.querySelectorAll('div[role="option"]'));
             const visibleOptions = allOptions.filter(o => {
                 const style = win.getComputedStyle(o);
                 return style.display !== 'none' && style.visibility !== 'hidden' && o.offsetParent !== null;
             });

             if (visibleOptions.length > 0) {
                 let target = null;
                 const validOptions = visibleOptions.filter(o => (o.innerText || "").trim().length > 0 && (o.innerText || "").trim() !== "Choose");
                 
                 if (question) {
                     const choice = normalize(selectWeighted(question.options).value);
                     target = validOptions.find(o => normalize(o.dataset.value || o.innerText) === choice);
                 }
                 
                 if (!target && validOptions.length > 0) target = validOptions[Math.floor(Math.random() * validOptions.length)];
                 
                 if (target) {
                     simulateClick(win, target);
                 } else {
                     doc.body.click(); 
                 }
             }
             await sleep(200);
             continue;
        }

        // D. Text Inputs (Heuristics)
        if (textInput) {
             let val = "";
             
             // 0. CUSTOM CONFIG: Prioritize user-defined custom answers
             if (CONFIG.customFieldResponses && question && CONFIG.customFieldResponses[question.id]) {
                 const answers = CONFIG.customFieldResponses[question.id];
                 if (answers && answers.length > 0) {
                     val = answers[runIndex % answers.length];
                 }
             }
             
             
             // 2. NAME FIELDS: Always fill name fields with provided names
             if (!val && isPersonalName(itemTitleRaw)) {
                 val = CONFIG.names.length > 0 ? CONFIG.names[runIndex % CONFIG.names.length] : "Auto User";
             }
             
             // 3. EMAIL FIELDS: Fill with random email if requested
             if (!val && isPersonalEmail(itemTitleRaw)) {
                 const baseName = CONFIG.names.length > 0 ? CONFIG.names[runIndex % CONFIG.names.length].toLowerCase().replace(/\s+/g, '.') : 'user' + runIndex;
                 const domains = ['gmail.com', 'yahoo.com', 'outlook.com', 'icloud.com'];
                 val = baseName + Math.floor(Math.random() * 99) + '@' + domains[Math.floor(Math.random() * domains.length)];
             }

             // 4. PHONE FIELDS: Fill with random number
             if (!val && isPhoneQuestion(itemTitleRaw)) {
                 const prefix = ['9', '8', '7', '6'][Math.floor(Math.random() * 4)];
                 const tail = Math.floor(Math.random() * 1000000000).toString().padStart(9, '0');
                 val = prefix + tail;
             }
             
             // 5. SKIP ALL OTHER TEXT FIELDS
             // If no custom response and not a name/email/phone field, leave blank


             if (val) {
                await simulateTyping(win, textInput, val);
             }
        }

      } catch (e) { console.warn('Fill error on item', e); }
    }
  };

  // --- CONTROLLER LOGIC ---
  createHUD();
  let completed = 0;
  
  updateHUD(completed, 'Opening Runner Window...', 'INIT');
  
  // Open small background window
  let runner = window.open(CONFIG.formUrl, 'SubmitraRunner', 'width=300,height=400,menubar=no,toolbar=no,location=yes,status=yes,left=5000,top=5000');
  
  // Attempt to background it
  if (runner) {
      setTimeout(() => {
          runner.blur();
          window.focus();
      }, 500);
  }
  
  if (!runner) {
      updateHUD(completed, 'POPUP BLOCKED! ALLOW POPUPS.', 'ERROR');
      alert('Submitra: Please allow popups to run the automation.');
      return;
  }

  const waitForLoad = async () => {
      let attempts = 0;
      while (attempts < 60) {
          try {
              if (runner.closed) throw new Error('Window closed');
              // Simple check for listitems
              if (runner.document.querySelectorAll('div[role="listitem"]').length > 0) return true;
          } catch (e) {}
          await sleep(500);
          attempts++;
      }
      return false;
  };

  try {
      while (completed < CONFIG.targetCount) {
          if (runner.closed) {
              updateHUD(completed, 'Runner closed. Stopped.', 'ERROR');
              break;
          }

          updateHUD(completed, 'Waiting for form...', 'RUNNING');
          const loaded = await waitForLoad();
          
          if (!loaded) {
              // Check if success page
              try {
                  const body = runner.document.body.innerText.toLowerCase();
                  if (body.includes('submit another') || body.includes('recorded')) {
                      runner.location.href = CONFIG.formUrl;
                      await sleep(2000);
                      continue;
                  }
              } catch(e) {}

              // Reload
              runner.location.href = CONFIG.formUrl;
              await sleep(3000);
              continue;
          }

          // Fill
          updateHUD(completed, \`Filling Form (\${completed + 1})...\`, 'RUNNING');
          
          let pageCount = 0;
          const MAX_PAGES = 10;
          let formSubmitted = false;

          while (pageCount < MAX_PAGES && !formSubmitted) {
              await fillForm(runner, completed);
              await sleep(1000); 

              // Find Action Buttons (Nuclear Option)
              const candidates = Array.from(runner.document.querySelectorAll('div[role="button"], button, span'));
              
              const getClickable = (el) => {
                  return el.closest('div[role="button"]') || el.closest('button') || el;
              };

              const submitCandidate = candidates.find(b => {
                  const t = normalize(b.innerText);
                  // Strict or Inclusive check, excluding "Back" or "Clear"
                  if (t.includes('back') || t.includes('clear') || t.includes('annuler')) return false;
                  return t === 'submit' || t.includes('submit') || t === 'envoyer' || t === 'enviar' || t === 'send';
              });
              
              const nextCandidate = candidates.find(b => {
                  const t = normalize(b.innerText);
                  if (t.includes('back') || t.includes('clear')) return false;
                  // Expanded keywords for better multi-section support
                  return t === 'next' || t.includes('next') || t === 'suivant' || t === 'siguiente' || t === 'continue' || t.includes('page') || t.includes('section') || t.includes('pÃ¡gina') || t === 'adelante';
              });
              
              const submitBtn = submitCandidate ? getClickable(submitCandidate) : null;
              const nextBtn = nextCandidate ? getClickable(nextCandidate) : null;

              if (submitBtn) {
                  updateHUD(completed, 'Submitting...', 'RUNNING');
                  simulateClick(runner, submitBtn);
                  formSubmitted = true;
                  break;
              } else if (nextBtn) {
                  updateHUD(completed, \`Moving to Page \${pageCount + 2}...\`, 'RUNNING');
                  simulateClick(runner, nextBtn);
                  
                  // Wait for Page Transition
                  // We detect transition by checking if the Next button disappears or new fields appear
                  // Simple heuristic: wait until the "Next" button we clicked is gone or header changes
                  await sleep(2000); 
                  let wait = 0;
                  while (wait < 10) {
                      const currentNext = Array.from(runner.document.querySelectorAll('div[role="button"], button'))
                                          .find(b => {
                                              const t = normalize(b.innerText);
                                              return t === 'next' || t.includes('next') || t === 'suivant' || t === 'siguiente' || t === 'continue';
                                          });
                      const currentSubmit = Array.from(runner.document.querySelectorAll('div[role="button"], button'))
                                            .find(b => {
                                                const t = normalize(b.innerText);
                                                return t === 'submit' || t.includes('submit') || t === 'envoyer' || t === 'enviar';
                                            });
                      
                      if (!currentNext || currentSubmit) break;
                      await sleep(500);
                      wait++;
                  }
                  
                  pageCount++;
              } else {
                  // No buttons found? Maybe last page or error.
                  // Try to find submit again loosely or break?
                  console.warn('No Submit or Next button found. Retrying scan...');
                  await sleep(2000);
                  if (pageCount > 0) break; // If we moved pages, maybe we are stuck.
              }
          }
          
          // Verify Success (Robust Loop)
          let success = false;
          let attempts = 0;
          
          while (attempts < 25) { 
              await sleep(800);
              try {
                  const body = normalize(runner.document.body.innerText);
                  // Check various success signals
                  if (body.includes('submit another') || body.includes('recorded') || body.includes('envoyer une autre') || body.includes('enviar otra') || body.includes('thank you') || body.includes('merci') || body.includes('gracias')) {
                      success = true;
                      break;
                  }
              } catch(e) {}
              attempts++;
          }

          if (success || attempts >= 25) { // If success OR timeout (assume success and try to loop)
              completed++;
              updateHUD(completed, 'Response Recorded!', 'RUNNING');
              
              if (completed < CONFIG.targetCount) {
                 try {
                      // NUCLEAR RESTART: Look for link OR Button OR just reload
                      const doc = runner.document;
                      
                      // 1. Try standard 'Submit another' link
                      const links = Array.from(doc.querySelectorAll('a'));
                      const reloadLink = links.find(a => {
                          const t = normalize(a.innerText);
                          return t.includes('submit another') || t.includes('envoyer une autre') || t.includes('enviar otra');
                      });
                      
                      if (reloadLink) {
                          simulateClick(runner, reloadLink);
                      } else {
                          // 2. Try looking for ANY text element like "Submit another" that might be clickable (custom themes)
                          const candidates = Array.from(doc.querySelectorAll('div, span, button'));
                          const reloadCandidate = candidates.find(el => {
                              const t = normalize(el.innerText);
                              return t.includes('submit another') || t.includes('envoyer une autre') || t.includes('enviar otra');
                          });
                          
                          if (reloadCandidate) {
                             simulateClick(runner, reloadCandidate);
                          } else {
                              // 3. Fallback: Force Reload URL
                              // console.log('Reloading form...');
                              runner.location.href = CONFIG.formUrl;
                          }
                      }
                  } catch (e) {
                      runner.location.href = CONFIG.formUrl;
                  }
                  await sleep(2500); // Give time for reload
              }
          } else {
              // Retry reload if stuck
              runner.location.href = CONFIG.formUrl;
              await sleep(2500);
          }
      }
      
      // Mark token as used
      localStorage.setItem('af_token_' + CONFIG.token.tokenId, 'used');

      // Show Success UI
      const hud = document.getElementById('submitra-hud');
      if (hud) {
          while (hud.firstChild) {
              hud.removeChild(hud.firstChild);
          }
          // Apply Premium Styles
          hud.style.cssText = 'position:fixed;bottom:20px;right:20px;width:340px;background:rgba(15, 23, 42, 0.95);backdrop-filter:blur(16px);color:white;padding:24px;border-radius:24px;z-index:999999;box-shadow:0 20px 50px -12px rgba(0,0,0,0.8), 0 0 0 1px rgba(251,191,36,0.3), 0 0 40px rgba(251,191,36,0.1);font-family:system-ui,-apple-system,sans-serif;display:flex;flex-direction:column;align-items:center;text-align:center;transition:all 0.5s cubic-bezier(0.16, 1, 0.3, 1);';
          
          // Icon Container
          const iconContainer = document.createElement('div');
          iconContainer.style.cssText = 'width:64px;height:64px;background:linear-gradient(135deg, rgba(251,191,36,0.2), rgba(245,158,11,0.2));border-radius:50%;display:flex;align-items:center;justify-content:center;margin-bottom:16px;box-shadow:0 0 30px rgba(251,191,36,0.2);border:1px solid rgba(251,191,36,0.2);animation:af-pulse 2s infinite;';
          
          // Premium SVG Logo (Safety Checkmark)
          const svgNS = "http://www.w3.org/2000/svg";
          const logoSvg = document.createElementNS(svgNS, "svg");
          logoSvg.setAttribute("width", "32");
          logoSvg.setAttribute("height", "32");
          logoSvg.setAttribute("viewBox", "0 0 24 24");
          logoSvg.setAttribute("fill", "none");
          logoSvg.setAttribute("stroke", "#fbbf24"); // Amber 400
          logoSvg.setAttribute("stroke-width", "3");
          logoSvg.setAttribute("stroke-linecap", "round");
          logoSvg.setAttribute("stroke-linejoin", "round");
          
          const polyline = document.createElementNS(svgNS, "polyline");
          polyline.setAttribute("points", "20 6 9 17 4 12");
          logoSvg.appendChild(polyline);
          
          iconContainer.appendChild(logoSvg);
          hud.appendChild(iconContainer);
          
          // Title
          const title = document.createElement('div');
          title.textContent = 'All Jobs Completed';
          title.style.cssText = 'color:#fbbf24;font-weight:800;font-size:20px;margin-bottom:6px;letter-spacing:-0.5px;text-shadow:0 2px 10px rgba(251,191,36,0.2);';
          hud.appendChild(title);
          
          // Subtitle
          const sub = document.createElement('div');
          sub.textContent = 'Submitra Gold has finished the sequence.';
          sub.style.cssText = 'color:#94a3b8;font-size:13px;margin-bottom:12px;font-weight:500;';
          hud.appendChild(sub);
          
          // Auto-Close Logic: Close runner immediately, Keep HUD Open
          if(runner && !runner.closed) runner.close();
          
          const countDiv = document.createElement('div');
          countDiv.style.cssText = 'font-size:12px;color:#4ade80;margin-bottom:24px;background:rgba(74, 222, 128, 0.1);padding:4px 12px;border-radius:12px;border:1px solid rgba(74, 222, 128, 0.2);';
          countDiv.textContent = 'Runner Closed. Job Complete.';
          hud.appendChild(countDiv);
          
          // Button Group
          const btnGroup = document.createElement('div');
          btnGroup.style.cssText = 'display:flex;gap:10px;width:100%;';
          
          // Common Button Style
          const btnStyle = 'flex:1;border:none;padding:12px;border-radius:12px;font-weight:600;font-size:13px;cursor:pointer;transition:all 0.2s;display:flex;align-items:center;justify-content:center;gap:6px;';
          
          // Go to Website Button
          const websiteBtn = document.createElement('button');
          websiteBtn.style.cssText = btnStyle + 'background:rgba(255,255,255,0.05);color:white;border:1px solid rgba(255,255,255,0.1);';
          
          const websiteText = document.createElement('span');
          websiteText.textContent = 'Go to Website';
          websiteBtn.appendChild(websiteText);
          
          // External Link Icon SVG
          const linkSvg = document.createElementNS(svgNS, "svg");
          linkSvg.setAttribute("width", "12");
          linkSvg.setAttribute("height", "12");
          linkSvg.setAttribute("viewBox", "0 0 24 24");
          linkSvg.setAttribute("fill", "none");
          linkSvg.setAttribute("stroke", "currentColor");
          linkSvg.setAttribute("stroke-width", "3");
          linkSvg.setAttribute("stroke-linecap", "round");
          linkSvg.setAttribute("stroke-linejoin", "round");
          
          // Path 1
          const path1 = document.createElementNS(svgNS, "path");
          path1.setAttribute("d", "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6");
          linkSvg.appendChild(path1);
          
          // Polyline
          const poly2 = document.createElementNS(svgNS, "polyline");
          poly2.setAttribute("points", "15 3 21 3 21 9");
          linkSvg.appendChild(poly2);
          
          // Line
          const line1 = document.createElementNS(svgNS, "line");
          line1.setAttribute("x1", "10");
          line1.setAttribute("y1", "14");
          line1.setAttribute("x2", "21");
          line1.setAttribute("y2", "3");
          linkSvg.appendChild(line1);
          
          websiteBtn.appendChild(linkSvg);

          websiteBtn.onmouseover = () => { websiteBtn.style.background = 'rgba(255,255,255,0.1)'; };
          websiteBtn.onmouseout = () => { websiteBtn.style.background = 'rgba(255,255,255,0.05)'; };
          websiteBtn.onclick = () => { window.open(CONFIG.appOrigin, '_blank'); };
          btnGroup.appendChild(websiteBtn);

          // Close Button
          const closeBtn = document.createElement('button');
          closeBtn.textContent = 'Close Controller';
          closeBtn.style.cssText = btnStyle + 'background:linear-gradient(135deg, #fbbf24 0%, #d97706 100%);color:#0f172a;box-shadow:0 4px 12px rgba(251,191,36,0.3);';
          closeBtn.onmouseover = () => { closeBtn.style.transform = 'translateY(-1px)'; closeBtn.style.boxShadow = '0 6px 16px rgba(251,191,36,0.4)'; };
          closeBtn.onmouseout = () => { closeBtn.style.transform = 'translateY(0)'; closeBtn.style.boxShadow = '0 4px 12px rgba(251,191,36,0.3)'; };
          closeBtn.onclick = () => { 
              hud.style.transform = 'scale(0.9) translateY(20px)';
              hud.style.opacity = '0';
              setTimeout(() => { hud.remove(); runner.close(); }, 300);
          };
          btnGroup.appendChild(closeBtn);
          
          hud.appendChild(btnGroup);
          
          // Add Animation Keyframes
          if (!document.getElementById('af-styles')) {
              const styleSheet = document.createElement('style');
              styleSheet.id = 'af-styles';
              styleSheet.textContent = '@keyframes af-pulse { 0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.4); } 70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(251, 191, 36, 0); } 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(251, 191, 36, 0); } }';
              document.head.appendChild(styleSheet);
          }
      }

  } catch (e) {
      console.error(e);
      updateHUD(completed, 'Error: ' + e.message, 'ERROR');
  }

})();
`;
};